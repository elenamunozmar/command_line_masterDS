ls
echo $SHELL
clear
ls
echo $SHELL
whoami
echo $HOST
echo $TERM
echo elena
echo repiteloquedigo
echo $USER
echo $
echo $USER
echo "$user"
echo "$USER"
echo '$USER'
echo 'comillas simples para literal $USER'
USER_NAME=elena
echo $USER_NAME
date
echo "hoy es el dÃ­a `date`" 
'las tildes se usan para evaluar lo que metas dentro'
echo 'no se puede anidar con tildes'
echo "en este directorio encuentro lo siguiente : $(ls)"
"si no cierras las comilas,\
se lo toma como salto de linea\
\
"
"con ctrl + c es seÃ±al de interrupcion"
'hola'
echo 'la backlash \ es para caracteres especiales'
echo "a\n"
echo "\n es para salto de linea"
echo "a\nb"
echo this is echo
echo ghola
echo para escribir multiples comandos de lineas se usa el ;
echo holi; date; echo adiosi
cd Data/shell
echo cd es para change directory
cd /home/dsc/Data/shell
cat Text_exmple.txt
cat Tex_example.txt
cd /home/dsc/Documents
cat Text_example.txt
cd /home/dsc/Data/shell
cat Text_example.txt
cat Text_example.txt Text_example.txt
cat -n Text_example.txt
pwd
cd .
cd ../
cd ../..
cd ..
cd ../
cd /home/dsc/Data/shell
cd - 
cd -
cd-
cd \home
cd \\

ls
ls - a
ls-a
ls -a
ls -l
ls -1
ls -s
ls -l
echo 'los permisos son: yo, mi grupo y el resto. Yo serÃ­a el primer dsc, el grupo seria el segundo dsc'
echo 'los permisos se dan en gruo de tres. En este caso los tendrÃ­a todos: drwx(read, writte & execute del primer ususario) rwx(permisos del grupo) -x (permisos para todo el mundo=\
)"\
'
echo 'cuidado al quitar el permiso de ejecutar en un directorio porque quiere decir que NO SE VA A PODER ACCEDER AL DIRECTORIO'
mkdir minuevofolder
ls -ls
mkdir holi
touch minuevoarchivo
ls -l
mkdir -p level1/level2/level3
ls level1/level2/level3
ls -l
echo 'NUNCA PONER rm -rf /'
echo 'TE BORRA EL ORDENADOR COMPLETO'
echo 'vamos a clonar archivos de un repo'
echo 'vamos a usar el programa git, que es un control de versiones y gestionar proyectos'
echo 'git es un repositorio de checkpoints de tu codigo'
echo 'es util cuando tengas checkpoints regulares de tu proyecto. Partes de un repo limpio'
git clone https://github.com/IgorAram/DS_CL_files.git
git clone https://github.com/IgorAramb/DS_CL_files.git  
cd DS_CL_files
 echo 'nos aparece lo de master porque estamos en un git (en un repositorio)'
 echo 'voy a borrar el archivo readme por error'
rm README.md
 echo 'salen estos numeros en morado porque se han modificado lineas respecto al repositorio'
git reset HEAD --hard
ls
man 
man ls
echo 'man te muestra la ayuda'
ls --help
gitconfig--global user.name 'Elena'
git config -- global user.name  'Elena Munoz'
cd /
cd /home
git clone Repositorio Master KSchool
git clone https://github.com/elenamunozmar/~Repositorio Master KSchool
git clone https://github.com/elenamunozmar/Repositorio Master KSchool.git
git clone https://github.com/elenamunozmar/master_kschool.git
gitconfig--global user.name "Elena M"
gitconfig ~ global user.name "Elena M"
gitconfig ~global user.name "Elena M"
git config ~ global user.name "Elena M"
git config ~ global user.mail "elena.18.mm@gmail.com"
git clone https://github.com/elenamunozmar/master_kschool.git 
cat/.gitconfig
cat .git/config
ls -l
git status
cd 
 git config ~ global user.name "Elena Munoz"
 git config ~ global user.mail elena.18.mm@gmail.com 
git config --global user.name "Elena Munoz"
git config --global user.mail elena.18.mm@gmail.com
git config --list
cat .git/config
ls -l
git clone https://github.com/elenamunozmar/master_kschool.git
ls -a
git config --
git --
git donfig
git config
cat .gitconfig
cd 
gedit .config/
gedit .gitconfig
cat .gitonfig
cat .gitconfig
ls
echo 'CREAMOS UN REPOSITORIO QUe SE LLAME REPOS'
mkdir Repos
cd Repos
git clone https://github.com/elenamunozmar/master_kschool.git
echo 'PARA USAR VIRGULILLA ~  -> ES ALT DERECHO + Ãƒ±   O ALT DERECHO + 4'
LS
ls
git clone https://github.com/elenamunozmar/master_kschool.git Otrodirectorio
ls
pwd
cd /home/dsc/Pictures
cd /home/dsc/Repos
git clone https://github.com/elenamunozmar/master_kschool.git ../Pictures
git clone https://github.com/elenamunozmar/master_kschool.git ../Pictures/Otro_directorio
ls ../Pictures
ls
echo 'vamos a crear un repositorio con linea de comandos'
git init
git init master_class_local_start
ll
cd master_class_local_start
git status
echo 'el master nos indica que el directorio es un repositorio'
cd ~
cd Repos
cd master_class_local_start
ls -a
echo 'Tenemos un directorio que se llama .git porque es donde esta todo el historial'
echo 'Ahi es donde se guardan los cambios'
touch first_file.txt
ll
gedit first_file.txt
echo  'para salir del editor de texto hay primero que guardar ctrl+s y luego salir con ctrl+q'
git add first_file.txt
git status
echo 'que este esten las letras en verde es que estÃƒn preparados'
git status
echo 'si no queremos meter el first_file... en un commit, hay que hacer git rm'
touch second_file.txt
git status
 git add second_file.txt
git status
echo 'cuando queremos guardarlo o hacer un checkpoint, hay que hacer un commit'
git commit  -m 'first commit'
git config --global user.mail "elena.18.mm@gmail.com"
git commit -m 'first commit'
git config --globla user.name "Elena Munoz"
git config --global user.mail "elena.18.mm@gmail.com"
git config --global user.name "Elena Munoz" 
git status
git config
git commit 'first commit'
git commit -m 'first commit'
git config --global user.mail "dsc@vm."
git commit -m 'first commit'
.git/config
git config --global user.mail "elena.18.mm@gmail.com"
git config --global user.name "Elena Munoz" 
git status
git commit -m 'first_commit'
cd
cat .gitconfig
gedit .gitconfig
cd -
git commit -m 'first_commit'
echo 'no me dejaba hacer el commit porque tenia user.mail en lugar de user.email'
echo 'para arreglarlo nos metemos en el editor de texto (gedit .gitconfig) y cambios mail por email'
echo 'vamos a crear un repositorio vacio en el github (en internet, no en local como hasta ahora)'
echo 'ademas, vamos a sincronizar el git local con el github'
echo 'primero se crea un repo vacio sin readme ni nada en github.com'
git remote add origin https://github.com/elenamunozmar/local_git.git
git remote add origin https://github.com/elenamunozmar/local_git.gi
git remove -v
git rm -v
git remote -v
echo 'remote -v te dice lo que estÃƒ sincronizado ahora mismo'
echo 'origin seria lo que tenemos en github y master seria lo que tenemos en local'
git branch -M master
git push -u origin master
echo 'aunque la contraseÃ±a no se mueva, esta escribiendo'
echo 'para traer los cambios o ver los cambios que ha hecho otra persona en el codigo, hay que hacer lo siguiente para verlo'
cat .history
cd 
cat.history
cd ~ 
cat .history
echo 'vamos a crear con las cosas de lineas de comandos, y vamos a ir metiendo lo de la linea de comando cada dos horas, por ejemplo'
cd Repos
git clone https://github.com/elenamunozmar/command_line_masterDS.git
cd command_line_masterDS
cp ~/.history
cp --help
cp ~/.history .
echo 'cp es para copia -> cp + directorio de lo que copiamos + directorio de donde lo copiamos'
echo 'como lo queriamos copiar donde estabamos ahora mismo, puede poner un punto solo'
ll
ls -a
echo 'ahora que tenemos un fichero nuevo, tenemos que hacer el git add'
git add .history
git commit -m "first_5H_of_master"
ls -a
echo 'copy es para llevarlo al directorio y add lo que hace es aÃ±adirlo a la lista de archivos a los que se le van a trackear los cambios'
echo 'es decir, una cosa es copiarla al directorio y otra es convertirla o aÃ±adirla al git, que es que le vamos a analizar los cambios en el repositorio git'
echo 'vamos a hace rcambios sobre .history'
gedit .history
cat .history
git reset --hard
echo 'esto lo que hace es volver al ultimo commit'
cat.history
echo 'existe el archivo .history pero no lo estÃƒ trackeando porque hemos vuelto al ultimo commit'
ls -a
git push 
echo 'con push lo subimos a github'
echo 'ahora en nuestro repositorio estara el readme que creamos al ppo y el archivo .history que hemos copiado y trackeado'
git commit -m "Date test $(date)"
git log
git push
mkdir ~/first_dir
cd
cd first_dir
touch Text_file.txt
ls -a
chmod --help
chmod -R 776 Text_file.txt
cat Text_file.txt
ls -l
mkdir ./sub1/sub2/sub3
mkdir -p ./sub1/sub2/sub3     
cd sub1/sub2/sub3
cd ../
cp ./Text_file.txt ./sub1
cd sub1
ls -a
mv --help
mv ./Text_file.txt  ./sub2/Text_file.txt.2
cd ./sub2
ls -a
cp ../ ./sub3
ls -a ./sub3
cd ./sub3
ls -a
echo "Change file name of first_dir/sub2/text_file.txt.2 to first_dir/sub2/text_file.txt.backupâ€ƒ½\
"
ls -a ~/first_dir/sub1/sub2
mv ~/first_dir/sub1/sub2/Text_file.txt.2 ~/first_dir/sub2/text_file.txt.backup     
echo "â€ƒ¼first_dir/sub2/text_file.txt.backupâ€ƒ½ to â€ƒ¼first_dirâ€ƒ½ directory as hidden file"
mv ~/first_dir/sub1/sub2/Text_file.txt.2 ~/first_dir/sub2/text_file.txt.backup     
Ã§
cd ../
ls -a
mv ./Text_file.txt.2 ./Text_file.txt.backup
ls -a
echo 'transformar el fichero a oculto'
mv ./Text_file.txt.backup ./.Text_file.txt.backup
ls -a
echo 'para hacerlo como oculto se le aÃ±ade un punto al principio del nombre'
rm -r sub2
ll
cd ../
rm -r sub2
ll
cd
cd Repos/command_line_masterDS
cp ~/.history
git add -u
git commit -m "Quick exercise -->$(date)"
cd ~
ls -a
cp ~/.history ~/Repos/command_line_masterDS
cd Repos/command_line_masterDS
ls -a
git add -u
git commit -m "Quick exercise -->$(date)"
echo 'vamo a usar alias'
ll
cd ~
alias
echo 'sirva para hacer shorcuts'
alias gl='git log'
gl
cd first_dir
gl
cd ~
cd Repos/command_line_masterDS
gl
alias gc='git commit -m'
echo 'estos alias solo funcionan en esta sesion de "shared"'
exit
gl
echo 'para que aparezca siempre, y no se borre cuando lo cerramos, hay que tocar un fichero'
gedit .zshrc
cp .zshrc .zshrc.backup
gedit .zshrc
gl
which ll
which cd
echo 'para ver que tipo es cada comando, con which'
which git
echo 'para ver la version de python'
which python
whereis python
echo 'sudo es super user'
sudo which python
echo 'el terminal es un editor de texto, porque meintras estamos escribiendo podemos cambiar cosas' 
echo 'usar alt+b para movernos por Las Palabras, alt+c es capitalizar las letras, alt+u es para hacer todas mayusculas, etc'
echo 'ALT+U'
echo 'para salir del terminal sin exit, en una linea vacia ctrl+D'
echo 'ctrl+l es para clear'
echo 'ver mas shorcuts en la hoja de chuleta'
echo 'ctrl+r es block search'
echo 'ctrl+r busca el ultimo comando con el termino buscado'
echo 'autocomplete lo hace dependiendo del contexto'
'\
\
'
echo 'autocomplete es al tabulador'
cd Data/opentraveldata
ll
head optd_aircraft.csv
echo 'el delimitador sera ^'
echo 'head da los primeros registros, como en R, pero cat te muestra todo el fichero'
echo 'en head se eseÃ±an 10 lineas por default, pero se pueden poner las que quieras'
head -n 3 optd_aircraft.csv
head -n -3 optd_
head -n -3 optd_aircraft.csv
echo 'con esto lo que hacemos es que nos van a enseÃ±ar todas las lineas excepto las tres primeras'
echo 'tail es igual que head pero al contrario, empezando desde abajo'
wc optd_aircraft.csv
echo 'wc nos dice que tiene 458 lineas, 1068 palabras y el numro de batch es 18612'
echo 'si solo quiero ver el num de palarbas es wc -w'
wc -w optd_aircraft.csv
cat optd_aircraft.csv
echo 'wc es word count'
cat optd_aircraft.csv | wc 
echo ' | esto sirve para anidar comandos, se puede hacer siempre que se este trabajando con texto'
echo 'como vemos, en este segundo metodo de wc no sale el nombre del fichero, porque al pasarlo por cat antes, el wc ya no sabe de donde viene el texto. En cat se llama a la funcion y se da como parametro el fichero, y en el wc le hemos dado como parametro la salida d eun funcion, no un fichero'
cat optd_aircraft.csv | wc | wc
cat optd_aircraft.csv | wc | wc | wc -w
cat optd_aircraft.csv | wc | wc | wc -w | wc
echo 'queremos el tamaÃ±o de las primeras 3 lineas'
head -3 optd_aircraft.csv | wc
head -3 optd_aircraft.csv
head -8 optd_aircraft.csv | tail -1
echo 'anidando head y tail podemos coger la linea de codigo que queramos, en este caso la linea 8'
cat -n optd_aircraft.csv 
cat -n optd_aircraft.csv | head -8
tail -1
cat -n optd_aircraft.csv | head -8 | tail -1
cat ~/.history
echo 'para redireccionar la salida en vez de que se muestre en pantalla, que vaya a un fichero es con ">"'
echo Test >test_file
cat test_file
which test_file
echo Test2 >test_file
echo 'se sobreescribe el fichero'
cat test_file
echo 'para aÃ±adir la info y no sobreescribir es asi'
echo Test3 >>test_file
cat test_file
ll
echo 'podemos redireccionar tambien la entrada'
<test_file wc
echo 'esto no se usa mucho'
wc test_file
cat -n optd_aircraft.csv | head -8 | tail -1
cat -n optd_aircraft.csv | head -8 | tail -1 | -1 >line_num8.csv
cat -n optd_aircraft.csv | head -8 | tail -1 |  >line_num8.csv
ll
cat line_num8.csv
echo "content utilities-quick exercises'\
\
'\
"
echo "2."
echo "How many words do first 5 lines of the Finn.txthave?"
Ã§
cd ~/Data/shell
head 5 Finn.txt | wc -w
head -n 5 Finn.txt | wc -w
head -n 3 Text_example.txt | cat n
cat --help
head -n 3 Text_example.txt | cat -n
head -n 5 Finn.txt | wc -w
head -n 3 Text_example.txt | cat -n
echo 'guardad los ultimo 20 comandos en un fichero distinto'
tail -20 ~/.history >last_20_lines
cat last_20_lines
echo 'File utilities - Quick Exercises'
echo 'find: buscar'
find 
find .
cd Ã±
cd ~
find ~/repos/
find ~/Repos
find ~/Repos | wc
find ~/Repos/command_line_masterDS | wc
find . -name "text_file"
echo 'ha intentado entrar en dos directioes donde se le han denegado los permisos'
find -name "tExt_file*" 
find -iname "tExt_file" 
find -iname "tExt_file*" 
find -iname "tExt_file*" -perm 777
find -iname "tExt_file*" ! -perm 777
echo ' ! se usa para decir que NO quieres esa condicion, p.e. devuelveme los archivos que NO tienen permisos 777'
echo 'se pueden buscar los ficheros vacios' 
find -maxdepth 3 -empty
find -mmin 60
find . -mmin  60
find . -mmin 900
find -mmin -900
cd Data
find . -type f 
find . -type f -iname ".csv*"
find . -type f -iname "*.csv"
find . -type f -iname "*.csv" | wc
find . -type f -iname "*.csv" -exec echo 'FOUN ONE'
find . -type f -iname "*.csv" -exec echo 'FOUN ONE'\;
find . -type f -iname "*.csv" -exec echo FOUND\;
find -iname "*.csv" -exec echo "FOUND"\;
find -iname "*.csv" -exec echo "FOUND";
find -iname "*.csv" -exec echo "FOUND" \;
echo 'hay que poner \;'
echo 'hay que poner \; para que te lo repita varias veces'
echo this ; echo that
echo this \; echo that
find -iname "*.csv" -exec echo "FOUND" ; echo "ONE" \;
find -iname "*.csv" -exec ls -l\;
find -iname "*.csv" -exec ls -l \;
find -iname "*.csv" -exec ls -l {} \;
echo 'al meter las {} quiere decir que lo va a meter en esa variable\
'
echo 'si quitas los corchetes, cada vez que encuentre uno, va a hacer la lista de todos, si hay 6 coincidencias, te vas a encontrar la lista 6 veces completas\
\
, por eso, si lo metes en {} estas metiendolo en una variable'
find -iname "*.csv" -exec ls -l {} \; -exec head 2 {} \;
find -iname "*.csv" -exec ls -l {} \; -exec head 2 {} \; | wc
find -iname "*.csv" -exec ls -l {} \; -exec head -n 2 {} \;
find -iname "*.csv" -exec ls -l {} \; -exec head -n 2 {} \; | wc
find -iname "*.csv" -exec ls -l {} \; | wc
find -iname "*.csv" -exec ls -l {} \; | wc \;
find -iname "*.csv" -exec zsh -c "ls -l {} \; | wc" \;
find -iname "*.csv" -exec zsh -c "ls -l {} | wc" \;
echo 'esto lo que hace es crear otra shell y evaluar lo que le metas en texto como formula'
echo $0
find -iname "*.csv" -exec zsh -c " ls -l {} | wc " \;
ls -l
ls -l | wc
echo 'File utilities -Quick exercises\
'
echo '1.'
find ~/ -mmin -60
echo '2.'
find ~/ -empty ! -perm 777
echo '3.   no lo voy a hacer porque le daria permisos a todo el mundo dentro de mi home'
find ~/Data -S -size
ls  ~/Data -S
ls -l -S ~/Data
wc -S ~/Data
ll -S ~/Data
ls -l -s -S ~/Data
ls -S ~/Data
ls -l -S ~/Data
ls -l -S ~/Data | head -n 3
find ~/ -exec zsh -c "ls -l -S ~/Data  {} \; | head -n 3" \;
find ~/ -exec zsh -c "ls -l -S ~/Data  {} | head -n 3" \;
find ~/Data -exec zsh -c "ls -l -S {} | head -n 3" \;
find ~/Data -exec zsh -c "ls -S {} | head -n 3" \;
echo '4.'
ls 
ls airline_tickets
ls opentraveldata
ls shell
ls challenge
ls us_dot
ls us_dot/otp/On_Time_Reporting_Carrier_On_Time_Performance_1987_present_2018_12.zip
echo '4. hay que ejecutar en cada directorio ls -S y head -n 3. El problema viene al ejecutar'
find ~/Data -iname="*.csv" -exec zsh -c " ls -S {} | head -n 3 " \;
find ~/Data -iname "*.csv" -exec zsh -c " ls -S {} | head -n 3 " \;
find ~/Data -iname "*.csv" -exec zsh -c " ls -S -l {} | head -n 3 " \;
find ~/Data
find ~/Data -type d 
find ~/Data -type d -exec ls -l -S 
find ~/Data -type d -exec ls -l -S \;
find ~/Data -type d -exec ls {} -l -S \;
find ~/Data -type d -exec ls {} -l -S \; head -n 3
find ~/Data -type d -exec ls {} -l -S \; head -n 3 \;
find ~/Data -type d -exec zsh -c "ls {} -l -S \; head -n 3" \;
find ~/Data -type d -exec zsh -c "ls {} -l -S \;" \;
find ~/Data -type d -exec zsh -c "ls {} -l -S \; wc | head -n 3 " \;
find ~/Data -type d -exec zsh -c "ls {} -l -S \; wc " \;
find ~/Data -type d -exec zsh -c "ls {} -l -S | wc " \;
find ~/Data -type d -exec zsh -c "ls {} -l -S >top3 " \;
top3
cat top3
find ~/Data -type d -exec zsh -c "ls {} -l -S " \;
find ~/Data -type d -exec zsh -c "ls {} -l -S \; >top3 " \;
find ~/Data -type d -exec zsh -c "ls {} -l -S \; head -n 3 " \;
find ~/Data -type d -exec zsh -c "ls -l -S {} \; " \;
find ~/Data -mindepth 1 -exec zsh -c "ls -l -S {} \; " \;
find ~/Data -mindepth 1 -type d -exec zsh -c "ls -l -S {} \; " \;
find ~/Data -mindepth 1 -type d -exec echo {} \; zsh -c "ls -l -S {} \; " \;
find ~/Data -mindepth 1 -type d -exec echo {} \; ls -l -S {} \;
find ~/Data -mindepth 1 -type d -exec echo {} \; ls {} -l -S \;
find ~/Data -mindepth 1 -type d -exec  ls {} -l -S \;
find ~/Data -mindepth 1 -type d -exec echo {} \; -exec zsh -c "ls -lSh {} | head -n 4" \;
echo 'vamos a meterlo en el github'
cd ~/Repos
cd command_line_masterDS
cp ~/.history .
